NAME
     fstat, fstat64, lstat, lstat64, stat, stat64, fstatat -- get file status

SYNOPSIS
     #include <sys/stat.h>

     int
     fstat(int fildes, struct stat *buf);

     int
     lstat(const char *restrict path, struct stat *restrict buf);

     int
     stat(const char *restrict path, struct stat *restrict buf);

     int
     fstatat(int fd, const char *path, struct stat *buf, int flag);

DESCRIPTION
      The stat() function obtains information about the file pointed to by path.
      Read, write or execute permission of the named file is not required, but
      all directories listed in the path name leading to the file must be
      searchable.

      The lstat() function is like stat() except in the case where the named
      file is a symbolic link; lstat() returns information about the link, while
      stat() returns information about the file the link references.  The
      attributes cannot be relied on in case of symbolic links.  In this case,
      the only attributes returned from an lstat() that refer to the symbolic
      link itself are the file type (S_IFLNK), size, blocks, and link count
      (always 1).

      The fstat() obtains the same information about an open file known by the
      file descriptor fildes.

      The fstatat() system call is equivalent to stat() and lstat() except in
      the case where the path specifies a relative path.  In this case the sta-
      tus is retrieved from a file relative to the directory associated with the
      file descriptor fd instead of the current working directory.

      The values for the flag are constructed by a bitwise-inclusive OR of flags
      from the following list, defined in <fcntl.h>:

      AT_SYMLINK_NOFOLLOW
              If path names a symbolic link, the status of the symbolic link is
              returned.

      If fstatat() is passed the special value AT_FDCWD in the fd parameter, the
      current working directory is used and the behavior is identical to a call
      to stat() or lstat() respectively, depending on whether or not the
      AT_SYMLINK_NOFOLLOW bit is set in flag.

      The buf argument is a pointer to a stat structure as defined by
      <sys/stat.h> and into which information is placed concerning the file.
      When the macro _DARWIN_FEATURE_64_BIT_INODE is not defined (see below for
      more information about this macro), the stat structure is defined as

      struct stat { /* when _DARWIN_FEATURE_64_BIT_INODE is NOT defined */
         dev_t    st_dev;    /* device inode resides on */
         ino_t    st_ino;    /* inode's number */
         mode_t   st_mode;   /* inode protection mode */
         nlink_t  st_nlink;  /* number of hard links to the file */
         uid_t    st_uid;    /* user-id of owner */
         gid_t    st_gid;    /* group-id of owner */
         dev_t    st_rdev;   /* device type, for special file inode */
         struct timespec st_atimespec;  /* time of last access */
         struct timespec st_mtimespec;  /* time of last data modification */
         struct timespec st_ctimespec;  /* time of last file status change */
         off_t    st_size;   /* file size, in bytes */
         quad_t   st_blocks; /* blocks allocated for file */
         u_long   st_blksize;/* optimal file sys I/O ops blocksize */
         u_long   st_flags;  /* user defined flags for file */
         u_long   st_gen;    /* file generation number */
     };

     The time-related fields of struct stat are as follows:

     st_atime         Time when file data last accessed.  Changed by the
                      mknod(2), utimes(2) and read(2) system calls.

     st_mtime         Time when file data last modified.  Changed by the
                      mknod(2), utimes(2) and write(2) system calls.

     st_ctime         Time when file status was last changed (inode data modi-
                      fication).  Changed by the chmod(2), chown(2), link(2),
                      mknod(2), rename(2), unlink(2), utimes(2) and write(2)
                      system calls.

     st_birthtime     Time of file creation. Only set once when the file is
                      created. This field is only available in the 64 bit inode
                      variants. On filesystems where birthtime is not avail-
                      able, this field is set to 0 (i.e. epoch).

     The size-related fields of the structures are as follows:

     st_blksize     The optimal I/O block size for the file.

     st_blocks      The actual number of blocks allocated for the file in
                    512-byte units.  As short symbolic links are stored in the
                    inode, this number may be zero.

     The status information word st_mode has the following bits:

     #define S_IFMT 0170000           /* type of file */
     #define        S_IFIFO  0010000  /* named pipe (fifo) */
     #define        S_IFCHR  0020000  /* character special */
     #define        S_IFDIR  0040000  /* directory */
     #define        S_IFBLK  0060000  /* block special */
     #define        S_IFREG  0100000  /* regular */
     #define        S_IFLNK  0120000  /* symbolic link */
     #define        S_IFSOCK 0140000  /* socket */
     #define        S_IFWHT  0160000  /* whiteout */
     #define S_ISUID 0004000  /* set user id on execution */
     #define S_ISGID 0002000  /* set group id on execution */
     #define S_ISVTX 0001000  /* save swapped text even after use */
     #define S_IRUSR 0000400  /* read permission, owner */
     #define S_IWUSR 0000200  /* write permission, owner */
     #define S_IXUSR 0000100  /* execute/search permission, owner */

     For a list of access modes, see <sys/stat.h>, access(2) and chmod(2).

     For a list of the file flags in the st_flags field, see <sys/stat.h> and
     chflags(2).

ERRORS
     The fstat() system call will fail if:

     [EBADF]            fildes is not a valid open file descriptor.

     [EFAULT]           Sb points to an invalid address.

     [EIO]              An I/O error occurs while reading from or writing to
                        the file system.

     The lstat() and stat() system calls will fail if:

     [EACCES]           Search permission is denied for a component of the path
                        prefix.

     [EFAULT]           Sb or name points to an invalid address.

     [EIO]              An I/O error occurs while reading from or writing to
                        the file system.

     [ELOOP]            Too many symbolic links are encountered in translating
                        the pathname.  This is taken to be indicative of a
                        looping symbolic link.

     [ENAMETOOLONG]     A component of a pathname exceeds {NAME_MAX} charac-
                        ters, or an entire path name exceeds {PATH_MAX} charac-
                        ters.

     [ENOENT]           The named file does not exist.

     [ENOTDIR]          A component of the path prefix is not a directory.

     The fstat(), lstat(), and stat() system calls will fail if:

     [EOVERFLOW]        The file size in bytes or the number of blocks allo-
                        cated to the file or the file serial number cannot be
                        represented correctly in the structure pointed to by
                        buf.

     In addition to the errors returned by the stat() and lstat(), fstatat()
     may fail if:

     [EBADF]            The path argument does not specify an absolute path and
                        the fd argument is neither AT_FDCWD nor a valid file
                        descriptor open for searching.

     [EINVAL]           The value of the flag argument is not valid.

     [ENOTDIR]          The path argument is not an absolute path and fd is
                        neither AT_FDCWD nor a file descriptor associated with
                        a directory.

RETURN VALUES
     Upon successful completion a value of 0 is returned.  Otherwise, a value
     of -1 is returned and errno is set to indicate the error.
